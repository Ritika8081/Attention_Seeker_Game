<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>EEG + Game Single Screen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
</head>

<body>
  <!-- Show actual game interface immediately -->
  <div id="mainContainer">
    <div id="contentContainer">
      <!-- Left column: Game -->
      <div id="gameSection">
        <canvas id="gameCanvas"></canvas>
      </div>

      <!-- Settings Button - Always visible -->
      <button id="settingsBtn" title="Settings"><i class="fas fa-cog"></i></button>

      <!-- Settings Modal -->
      <div id="settingsModal" class="modal">
        <div class="modal-content">
          <span class="close-modal">&times;</span>
          <h2><i class="fas fa-sliders-h"></i> Controls</h2>
          <div class="controls-group">
            <button id="connectBtn" class="btn"><i class="fas fa-plug"></i> Connect</button>
            <button id="disconnectBtn" class="btn"><i class="fas fa-unlink"></i> Disconnect</button>
            <button id="startBtn" class="btn"><i class="fas fa-play"></i> Start</button>
            <button id="stopBtn" class="btn"><i class="fas fa-stop"></i> Stop</button>
            <select id="channelSelector" style="display: none;">
              <option value="all">All Channels</option>
              <option value="ch0">Channel 0</option>
              <option value="ch1">Channel 1</option>
              <option value="ch2">Channel 2</option>
            </select>
            <canvas id="plotCanvas" style="display: none;"></canvas>

            <div class="slider-wrapper" style="display: none;">
              <label for="gainSlider"><i class="fas fa-sliders-h"></i> Gain:</label>
              <input type="range" id="gainSlider" min="0.1" max="5" step="0.1" value="1">
            </div>
          </div>
          <div id="statusText"><i class="fas fa-circle-notch fa-spin"></i> Waiting for connection...</div>

          <hr style="margin: 30px 0; border-color: rgba(255,255,255,0.1);">

          <h2><i class="fas fa-brain"></i> Beta Threshold Control</h2>
          <div class="threshold-control">
            <div class="slider-wrapper">
              <label for="betaThresholdSlider">
                <i class="fas fa-brain"></i> Beta Threshold:
              </label>
              <input type="range" id="betaThresholdSlider" min="0" max="100" step="1" value="40">
              <span id="betaThresholdValue">40%</span>
            </div>
          </div>

          <hr style="margin: 30px 0; border-color: rgba(255,255,255,0.1);">

          <h2><i class="fas fa-dumbbell"></i> EMG Threshold Control</h2>
          <div class="threshold-control">
            <div class="slider-wrapper">
              <label for="emgLeftThresholdSlider">
                <i class="fas fa-hand-point-left"></i> Left EMG Threshold:
              </label>
              <input type="range" id="emgLeftThresholdSlider" min="0" max="1000" step="5" value="50">
              <span id="emgLeftThresholdValue">50</span>
            </div>
            <div class="slider-wrapper">
              <label for="emgRightThresholdSlider">
                <i class="fas fa-hand-point-right"></i> Right EMG Threshold:
              </label>
              <input type="range" id="emgRightThresholdSlider" min="0" max="1000" step="5" value="50">
              <span id="emgRightThresholdValue">50</span>
            </div>

            <!-- Add real-time EMG value display -->
            <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px;">
              <div style="color: #00d4ff; font-size: 0.9rem;">
                <i class="fas fa-chart-line"></i> Live EMG Values:
              </div>
              <div style="display: flex; gap: 20px; margin-top: 5px;">
                <span>Left: <strong id="emgLeftLive">--</strong></span>
                <span>Right: <strong id="emgRightLive">--</strong></span>
              </div>
            </div>
          </div>

          <div id="output" class="threshold-output"></div>
        </div>
      </div>

    </div>
  </div>
  <!-- Game JS -->
  <script>
    // ============ GAME CODE ============
    const gameCanvas = document.getElementById("gameCanvas");
    const gctx = gameCanvas.getContext("2d");

    // Player spaceship with responsive positioning
    const player = {
      x: 0,
      y: 0,
      speed: 5,
      dx: 0,
      dy: 0,
      width: 50,
      height: 50
    };

    // Preload spaceship image with immediate fallback
    const spaceshipImg = new Image();
    spaceshipImg.src = "assets/spaceship.png";

    // Track if image is loaded
    let spaceshipImageLoaded = false;

    // Initialize game immediately without waiting
    function initializeGameImmediately() {
      resizeGameCanvas();
      drawInitialFrame();
      initializeGame();
    }

    // Draw initial frame with fallback
    function drawInitialFrame() {
      gctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
      updateNebulaColors();
      updateBackground();
      drawBackground();
      drawPlayer();
      if (enemies.length > 0) drawEnemies();
      if (bullets.length > 0) drawBullets();
    }

    // Updated drawPlayer with immediate fallback
    function drawPlayer() {
      if (spaceshipImg.complete && spaceshipImg.naturalWidth > 0 && spaceshipImageLoaded) {
        gctx.drawImage(spaceshipImg, player.x, player.y, player.width, player.height);
      } else {
        // Immediate fallback - draw a triangle spaceship
        gctx.fillStyle = '#00d4ff';
        gctx.beginPath();
        gctx.moveTo(player.x + player.width / 2, player.y); // Top point
        gctx.lineTo(player.x, player.y + player.height); // Bottom left
        gctx.lineTo(player.x + player.width, player.y + player.height); // Bottom right
        gctx.closePath();
        gctx.fill();

        // Add a glow effect
        gctx.strokeStyle = '#64ffda';
        gctx.lineWidth = 2;
        gctx.stroke();
      }
    }

    // Handle image loading in background
    spaceshipImg.onload = () => {
      const aspectRatio = spaceshipImg.width / spaceshipImg.height;
      player.height = player.width / aspectRatio;
      setPlayerPosition();
      spaceshipImageLoaded = true;
      console.log("‚úÖ Spaceship image loaded successfully");
    };

    // Handle image loading error
    spaceshipImg.onerror = () => {
      console.log("‚ö†Ô∏è Spaceship image failed to load - using fallback");
      spaceshipImageLoaded = false;
    };

    // Also preload asteroid images
    const asteroidImages = [];
    let asteroidImagesLoaded = 0;
    const totalAsteroidImages = 14;

    for (let i = 1; i <= totalAsteroidImages; i++) {
      const img = new Image();
      img.src = `assets/asteroids/asteroid${i}.png`;
      img.onload = () => {
        asteroidImagesLoaded++;
        if (asteroidImagesLoaded === totalAsteroidImages) {
          console.log("‚úÖ All asteroid images loaded");
        }
      };
      img.onerror = () => {
        console.log(`‚ö†Ô∏è Asteroid image ${i} failed to load`);
      };
      asteroidImages.push(img);
    }

    // Updated drawEnemies with fallback
    function drawEnemies() {
      enemies.forEach(enemy => {
        if (enemy.image && enemy.image.complete && enemy.image.naturalWidth > 0) {
          gctx.drawImage(enemy.image, enemy.x, enemy.y, enemy.width, enemy.height);
        } else {
          // Fallback - draw a red diamond
          gctx.fillStyle = "#ff4444";
          gctx.beginPath();
          gctx.moveTo(enemy.x + enemy.width / 2, enemy.y); // Top
          gctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height / 2); // Right
          gctx.lineTo(enemy.x + enemy.width / 2, enemy.y + enemy.height); // Bottom
          gctx.lineTo(enemy.x, enemy.y + enemy.height / 2); // Left
          gctx.closePath();
          gctx.fill();

          // Add border
          gctx.strokeStyle = "#ff8888";
          gctx.lineWidth = 2;
          gctx.stroke();
        }
      });
    }

    // Initialize game immediately when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      console.log("üéÆ Initializing game immediately...");

      // Set initial canvas size
      resizeGameCanvas();

      // Draw initial frame
      drawInitialFrame();

      // Start game
      initializeGame();
    });

    // Remove the old spaceshipImg.onload initialization:
    // Comment out or remove this block:
    /*
    spaceshipImg.onload = () => {
      const aspectRatio = spaceshipImg.width / spaceshipImg.height;
      player.height = player.width / aspectRatio;
      setPlayerPosition();
      resizeGameCanvas();
      initializeGame();
    };
    */

    let emgLeftMaxRef = 1;
    let emgRightMaxRef = 1;

    let betaThreshold = 40; // Changed from 0.4 to 40 for percentage

    const settingsBtn = document.getElementById('settingsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const closeModal = document.querySelector('.close-modal');
    let emgLeftThreshold = 50;   // Lower default threshold
    let emgRightThreshold = 50;  // Lower default threshold
    let envLeft = 0;
    let envRight = 0;
    const EMG_MAX_REF = 3000; // Can be adjusted based on your signal amplitude

    // Preload custom asteroid images (asteroid1.png ... asteroid14.png)
    // (Already declared and loaded above, so this block is removed)

    // Background objects (stars, planets)
    const stars = [];
    const planets = [];
    for (let i = 0; i < 100; i++) {
      stars.push({
        x: Math.random() * gameCanvas.width,
        y: Math.random() * gameCanvas.height,
        radius: Math.random() * 2 + 1,
        speed: Math.random() * 2 + 0.5
      });
    }

    settingsBtn.addEventListener('click', () => {
      settingsModal.style.display = 'block';
    });

    closeModal.addEventListener('click', () => {
      settingsModal.style.display = 'none';
    });

    window.addEventListener('click', (e) => {
      if (e.target === settingsModal) {
        settingsModal.style.display = 'none';
      }
    });

    window.addEventListener('load', () => {
      // Beta threshold slider
      const betaThresholdSlider = document.getElementById('betaThresholdSlider');
      const betaThresholdValue = document.getElementById('betaThresholdValue');

      betaThresholdSlider.addEventListener('input', (e) => {
        betaThreshold = parseFloat(e.target.value);
        betaThresholdValue.textContent = betaThreshold + '%';
        console.log('Beta threshold set to:', betaThreshold + '%');
      });

      // EMG Left threshold slider
      const emgLeftThresholdSlider = document.getElementById('emgLeftThresholdSlider');
      const emgLeftThresholdValueSpan = document.getElementById('emgLeftThresholdValue');

      emgLeftThresholdSlider.addEventListener('input', (e) => {
        emgLeftThreshold = parseFloat(e.target.value);
        emgLeftThresholdValueSpan.textContent = emgLeftThreshold;
        console.log('EMG Left threshold set to:', emgLeftThreshold);
      });

      // EMG Right threshold slider
      const emgRightThresholdSlider = document.getElementById('emgRightThresholdSlider');
      const emgRightThresholdValueSpan = document.getElementById('emgRightThresholdValue');

      emgRightThresholdSlider.addEventListener('input', (e) => {
        emgRightThreshold = parseFloat(e.target.value);
        emgRightThresholdValueSpan.textContent = emgRightThreshold;
        console.log('EMG Right threshold set to:', emgRightThreshold);
      });
    });

    function updateBackground() {
      stars.forEach(star => {
        star.y += star.speed;
        if (star.y > gameCanvas.height) {
          star.y = 0;
          star.x = Math.random() * gameCanvas.width;
        }
      });

    }

    // Nebula effect
    let nebulaColor1 = { r: 50, g: 0, b: 150 };
    let nebulaColor2 = { r: 0, g: 0, b: 100 };
    function updateNebulaColors() {
      const t = Date.now();

      // Violet-magenta base (nebulaColor1)
      nebulaColor1.r = 40 + Math.sin(t * 0.0002) * 30; // Reddish-magenta (40‚Äì70)
      nebulaColor1.g = 0;                             // Keep dark (optional: try 10‚Äì20 for subtle green)
      nebulaColor1.b = 60 + Math.cos(t * 0.00015) * 40; // Bluish glow (20‚Äì100)

      // Blue-teal highlight (nebulaColor2)
      nebulaColor2.r = 0;
      nebulaColor2.g = 20 + Math.sin(t * 0.00025) * 20; // Teal-greenish (0‚Äì40)
      nebulaColor2.b = 40 + Math.sin(t * 0.0003) * 30;  // Deep blue (10‚Äì70)
    }


    function drawBackground() {
      updateNebulaColors();
      let gradient = gctx.createLinearGradient(0, 0, gameCanvas.width, gameCanvas.height);
      const clamp = (value, max = 50) => Math.min(Math.abs(value) % 256, max);

      gradient.addColorStop(
        0,
        `rgb(${clamp(nebulaColor1.r)}, 0, ${clamp(nebulaColor1.b)})`
      );
      gradient.addColorStop(
        1,
        `rgb(0, ${clamp(nebulaColor2.g)}, ${clamp(nebulaColor2.b)})`
      );

      gctx.fillStyle = gradient;
      gctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

      // Stars
      gctx.fillStyle = "white";
      stars.forEach(star => {
        gctx.beginPath();
        gctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
        gctx.fill();
      });

      // Planets
      gctx.fillStyle = "rgba(100, 100, 255, 0.8)";
      planets.forEach(planet => {
        gctx.beginPath();
        gctx.arc(planet.x, planet.y, planet.size, 0, Math.PI * 2);
        gctx.fill();
      });
    }
    class EMGFilter {
      constructor() {
        // Internal filter state
        this.z1 = 0;
        this.z2 = 0;
        this.x1 = 0;
      }

      /**
       * Process one sample through the 70‚ÄØHz biquad section.
       * @param {number} input Raw EMG sample
       * @returns {number} Filtered output
       */
      process(input) {

        // (coefficients for 500‚ÄØHz sampling, 70‚ÄØHz center)
        this.x1 = input - (-0.82523238 * this.z1) - (0.29463653 * this.z2);

        // Compute filter output from SOS coefficients
        const output =
          0.52996723 * this.x1 +
          -1.05993445 * this.z1 +
          0.52996723 * this.z2;

        // Shift the delay elements
        this.z2 = this.z1;
        this.z1 = this.x1;

        return output;
      }
    }

    const EMGFilterLeft = new EMGFilter();
    const EMGFilterRight = new EMGFilter();

    // ---------------- Added Envelope Filter for EMG Data ----------------
    class EnvelopeFilter {
      constructor(bufferSize) {
        this.bufferSize = bufferSize;
        this.circularBuffer = new Array(bufferSize).fill(0);
        this.sum = 0;
        this.dataIndex = 0;
      }

      getEnvelope(absEmg) {
        this.sum -= this.circularBuffer[this.dataIndex];
        this.sum += absEmg;
        this.circularBuffer[this.dataIndex] = absEmg
        this.dataIndex = (this.dataIndex + 1) % this.bufferSize;
        return this.sum / this.bufferSize;
      }
    }
    // Create envelope filters for each EMG channel
    const envelopeFilterLeft = new EnvelopeFilter(64);
    const envelopeFilterRight = new EnvelopeFilter(64);



    document.addEventListener("keydown", (event) => {
      if (event.key === "ArrowLeft") player.dx = -player.speed;
      if (event.key === "ArrowRight") player.dx = player.speed;
      if (event.key === "ArrowUp") player.dy = -player.speed;
      if (event.key === "ArrowDown") player.dy = player.speed;
    });
    document.addEventListener("keyup", () => {
      player.dx = 0;
      player.dy = 0;
    });

    function updatePlayer() {
      player.x += player.dx;
      player.y += player.dy;
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > gameCanvas.width) player.x = gameCanvas.width - player.width;
      if (player.y < 0) player.y = 0;
      if (player.y + player.height > gameCanvas.height) player.y = gameCanvas.height - player.height;
    }

    function drawPlayer() {
      if (spaceshipImg.complete && spaceshipImg.naturalWidth > 0 && spaceshipImageLoaded) {
        gctx.drawImage(spaceshipImg, player.x, player.y, player.width, player.height);
      } else {
        // Immediate fallback - draw a triangle spaceship
        gctx.fillStyle = '#00d4ff';
        gctx.beginPath();
        gctx.moveTo(player.x + player.width / 2, player.y); // Top point
        gctx.lineTo(player.x, player.y + player.height); // Bottom left
        gctx.lineTo(player.x + player.width, player.y + player.height); // Bottom right
        gctx.closePath();
        gctx.fill();

        // Add a glow effect
        gctx.strokeStyle = '#64ffda';
        gctx.lineWidth = 2;
        gctx.stroke();
      }
    }

    // Enemies
    const enemies = [];
    // Enhanced enemy spawning with limit
    const MAX_ENEMIES = 10; // Limit number of enemies on screen

    function spawnEnemy() {
      // Don't spawn if game is paused or too many enemies exist
      if (!gameRunning || !isPageVisible || enemies.length >= MAX_ENEMIES) {
        return;
      }

      const enemySize = 130;
      const randomIndex = Math.floor(Math.random() * asteroidImages.length);

      enemies.push({
        x: Math.random() * (gameCanvas.width - enemySize),
        y: -enemySize,
        width: enemySize,
        height: enemySize,
        speed: 2,
        image: asteroidImages[randomIndex],
        spawnTime: performance.now() // Track when enemy was spawned
      });
    }

    function updateEnemies() {
      enemies.forEach((enemy, i) => {
        if (gameRunning && isPageVisible) {
          enemy.y += enemy.speed;

          // Remove enemies that are off screen
          if (enemy.y > gameCanvas.height + enemy.height) {
            enemies.splice(i, 1);
          }
        }
      });
    }
    function drawEnemies() {
      enemies.forEach(enemy => {
        if (enemy.image && enemy.image.complete && enemy.image.naturalWidth > 0) {
          gctx.drawImage(enemy.image, enemy.x, enemy.y, enemy.width, enemy.height);
        } else {
          // Fallback - draw a red diamond
          gctx.fillStyle = "#ff4444";
          gctx.beginPath();
          gctx.moveTo(enemy.x + enemy.width / 2, enemy.y); // Top
          gctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height / 2); // Right
          gctx.lineTo(enemy.x + enemy.width / 2, enemy.y + enemy.height); // Bottom
          gctx.lineTo(enemy.x, enemy.y + enemy.height / 2); // Left
          gctx.closePath();
          gctx.fill();

          // Add border
          gctx.strokeStyle = "#ff8888";
          gctx.lineWidth = 2;
          gctx.stroke();
        }
      });
    }

    // Bullets
    const bullets = [];
    function shootBullet() {
      bullets.push({
        x: player.x + player.width / 2 - 5,
        y: player.y,
        width: 10,
        height: 20,
        speed: 5
      });
    }
    // Expose globally so EEG code can call it
    window.shootBullet = shootBullet;

    function updateBullets() {
      bullets.forEach((bullet, i) => {
        if (gameRunning && isPageVisible) {
          bullet.y -= bullet.speed;

          // Remove bullets that are off screen
          if (bullet.y < -bullet.height) {
            bullets.splice(i, 1);
          }
        }
      });
    }
    function drawBullets() {
      gctx.fillStyle = "yellow";
      bullets.forEach(bullet => {
        gctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
      });
    }

    function checkCollisions() {
      bullets.forEach((bullet, bIndex) => {
        enemies.forEach((enemy, eIndex) => {
          if (
            bullet.x < enemy.x + enemy.width &&
            bullet.x + bullet.width > enemy.x &&
            bullet.y < enemy.y + enemy.height &&
            bullet.y + bullet.height > enemy.y
          ) {
            enemies.splice(eIndex, 1);
            bullets.splice(bIndex, 1);
          }
        });
      });
    }

    // Add this code after your existing game variables
    let gameRunning = true;
    let lastTime = 0;
    let enemySpawnInterval = null;

    // Page Visibility API to detect when tab is hidden/visible
    let isPageVisible = !document.hidden;

    function handleVisibilityChange() {
      if (document.hidden) {
        // Page is hidden - pause the game
        pauseGame();
      } else {
        // Page is visible - resume the game
        resumeGame();
      }
    }

    function pauseGame() {
      console.log("üéÆ Game Paused - Tab Hidden");
      gameRunning = false;
      isPageVisible = false;

      // Clear enemy spawn interval
      if (enemySpawnInterval) {
        clearInterval(enemySpawnInterval);
        enemySpawnInterval = null;
      }
    }

    function resumeGame() {
      console.log("üéÆ Game Resumed - Tab Visible");
      gameRunning = true;
      isPageVisible = true;
      lastTime = performance.now(); // Reset timing

      // Restart enemy spawning
      startEnemySpawning();
    }

    // Enhanced enemy spawning with proper interval management
    function startEnemySpawning() {
      // Clear any existing interval first
      if (enemySpawnInterval) {
        clearInterval(enemySpawnInterval);
      }

      // Start new interval only if game is running
      if (gameRunning && isPageVisible) {
        enemySpawnInterval = setInterval(() => {
          if (gameRunning && isPageVisible) {
            spawnEnemy();
          }
        }, 2000);
      }
    }

    // Enhanced game loop with visibility check
    function gameLoop(currentTime) {
      // Only run game logic if page is visible and game is running
      if (!gameRunning || !isPageVisible) {
        requestAnimationFrame(gameLoop);
        return;
      }

      // Calculate delta time for smooth animation
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;

      // Skip frame if delta time is too large (tab was hidden)
      if (deltaTime > 100) {
        requestAnimationFrame(gameLoop);
        return;
      }

      gctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
      updateBackground();
      drawBackground();
      updatePlayer();
      updateEnemies();
      updateBullets();
      checkCollisions();
      drawPlayer();
      drawEnemies();
      drawBullets();

      requestAnimationFrame(gameLoop);
    }

    // Enhanced enemy update with bounds checking
    function updateEnemies() {
      enemies.forEach((enemy, i) => {
        if (gameRunning && isPageVisible) {
          enemy.y += enemy.speed;

          // Remove enemies that are off screen
          if (enemy.y > gameCanvas.height + enemy.height) {
            enemies.splice(i, 1);
          }
        }
      });
    }

    // Enhanced bullet update
    function updateBullets() {
      bullets.forEach((bullet, i) => {
        if (gameRunning && isPageVisible) {
          bullet.y -= bullet.speed;

          // Remove bullets that are off screen
          if (bullet.y < -bullet.height) {
            bullets.splice(i, 1);
          }
        }
      });
    }

    // Missing variables
    let selectedChannel = "all"; // Default to show all channels
    let gain = 1; // Default gain value
    let gamePaused = false; // Missing variable

    // Missing function: setPlayerPosition
    function setPlayerPosition() {
      player.x = (gameCanvas.width - player.width) / 2;
      player.y = gameCanvas.height - player.height - 20;
    }

    // Missing function: resizeGameCanvas
    function resizeGameCanvas() {
      gameCanvas.width = window.innerWidth;
      gameCanvas.height = window.innerHeight;

      // Responsive spaceship sizing
      const baseWidth = Math.min(250, gameCanvas.width * 0.12); // 12% of screen width
      player.width = baseWidth;

      if (spaceshipImg.complete && spaceshipImg.naturalWidth > 0) {
        const aspectRatio = spaceshipImg.width / spaceshipImg.height;
        player.height = player.width / aspectRatio;
      } else {
        player.height = baseWidth; // Fallback square ratio
      }

      setPlayerPosition();

      // Update background objects for new canvas size
      updateStarsForNewSize();
    }

    // Function to update stars when canvas resizes
    function updateStarsForNewSize() {
      // Update existing stars to fit new canvas size
      stars.forEach(star => {
        if (star.x > gameCanvas.width) star.x = Math.random() * gameCanvas.width;
        if (star.y > gameCanvas.height) star.y = Math.random() * gameCanvas.height;
      });

      // Add more stars if canvas got bigger
      while (stars.length < Math.min(200, gameCanvas.width * gameCanvas.height / 10000)) {
        stars.push({
          x: Math.random() * gameCanvas.width,
          y: Math.random() * gameCanvas.height,
          radius: Math.random() * 2 + 1,
          speed: Math.random() * 2 + 0.5
        });
      }
    }

    // Add window resize listener
    window.addEventListener("resize", resizeGameCanvas);

    // Fix the duplicate updateEnemies function - remove one of them
    // Keep only this version:
    function updateEnemies() {
      enemies.forEach((enemy, i) => {
        if (gameRunning && isPageVisible) {
          enemy.y += enemy.speed;

          // Remove enemies that are off screen
          if (enemy.y > gameCanvas.height + enemy.height) {
            enemies.splice(i, 1);
          }
        }
      });
    }

    // Remove the duplicate updateBullets function - keep only this version:
    function updateBullets() {
      bullets.forEach((bullet, i) => {
        if (gameRunning && isPageVisible) {
          bullet.y -= bullet.speed;

          // Remove bullets that are off screen
          if (bullet.y < -bullet.height) {
            bullets.splice(i, 1);
          }
        }
      });
    }

    // Remove the duplicate drawWaveform function
    // Keep only the version in the EEG section

    // Fix the drawWaveform function to handle missing variables
    function drawWaveform() {
      if (!plotCanvas || !plotCtx) return; // Safety check

      plotCtx.clearRect(0, 0, plotCanvas.width, plotCanvas.height);

      function drawChannel(data, color) {
        plotCtx.strokeStyle = color;
        plotCtx.lineWidth = 2;
        plotCtx.beginPath();
        for (let i = 0; i < data.length; i++) {
          const x = (i / (data.length - 1)) * plotCanvas.width;
          const y = plotCanvas.height / 2 - (data[i] * gain * (plotCanvas.height / 2));
          if (i === 0) plotCtx.moveTo(x, y);
          else plotCtx.lineTo(x, y);
        }
        plotCtx.stroke();
      }

      // Use default channel if selectedChannel is not defined
      const channel = selectedChannel || "all";

      if (channel === "all" || channel === "ch0") {
        drawChannel(dataCh0, "cyan");
      }
      if (channel === "all" || channel === "ch1") {
        drawChannel(dataCh1, "lime");
      }

      requestAnimationFrame(drawWaveform);
    }

    // Remove the duplicate initializeGame function and spaceshipImg.onload
    // Keep only this clean version:

    // Initialize game immediately when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      console.log("üéÆ Initializing game immediately...");

      // Set initial canvas size
      resizeGameCanvas();

      // Draw initial frame
      drawInitialFrame();

      // Start game
      initializeGame();
    });

    // Handle spaceship image loading in background
    spaceshipImg.onload = () => {
      const aspectRatio = spaceshipImg.width / spaceshipImg.height;
      player.height = player.width / aspectRatio;
      setPlayerPosition();
      spaceshipImageLoaded = true;
      console.log("‚úÖ Spaceship image loaded successfully");
    };

    // Fix visibility change handlers - remove duplicates
    document.addEventListener("visibilitychange", handleVisibilityChange);

    // Add the missing initializeGame function
    function initializeGame() {
      lastTime = performance.now();
      startEnemySpawning();
      gameLoop(lastTime);
    }
  </script>


  <!-- EEG + BLE Code -->
  <script>
    // ============ EEG CODE ============
    class Notch {
      constructor() {
        this.z1_1 = 0; this.z2_1 = 0;
        this.x_1 = 0;
        this.currentSamplingRate = 500;
      }
      setSamplingRate(rate) { this.currentSamplingRate = rate; }
      process(input, type) {
        if (!type) return input;
        let output = input;
        // Simple example: 50Hz notch for 500Hz
        if (this.currentSamplingRate === 500 && type === 1) {
          this.x_1 = output - (-1.56858163 * this.z1_1) - (0.96424138 * this.z2_1);
          output = 0.96508099 * this.x_1 + -1.56202714 * this.z1_1 + 0.96508099 * this.z2_1;
          this.z2_1 = this.z1_1;
          this.z1_1 = this.x_1;
        }
        return output;
      }
    }

    let notchFilterCh0 = new Notch();
    let notchFilterCh1 = new Notch();
    notchFilterCh0.setSamplingRate(500);
    notchFilterCh1.setSamplingRate(500);

    let device = null, server = null, controlChar = null, dataChar = null;
    let streaming = false, connected = false;

    const SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
    const DATA_CHAR_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
    const CONTROL_CHAR_UUID = "0000ff01-0000-1000-8000-00805f9b34fb";
    const SINGLE_SAMPLE_LEN = 7, BLOCK_COUNT = 10;
    const NEW_PACKET_LEN = SINGLE_SAMPLE_LEN * BLOCK_COUNT;

    let prevSampleCounter = null, samplesReceived = 0;
    const THRESHOLD = 0.5;
    let lastActionTime = 0;
    const DEBOUNCE_TIME = 1000;

    // Plot canvas for EEG waveform (renamed context variable to avoid collision)
    const plotCanvas = document.getElementById("plotCanvas");
    const plotCtx = plotCanvas.getContext("2d");
    function resizePlotCanvas() {
      plotCanvas.width = plotCanvas.clientWidth;
      plotCanvas.height = plotCanvas.clientHeight;
    }
    window.addEventListener("resize", resizePlotCanvas);
    resizePlotCanvas();

    let dataCh0 = new Array(500).fill(0);
    let dataCh1 = new Array(500).fill(0);

    let filterStateCh0 = { z1: 0, z2: 0, x1: 0 };
    let filterStateCh1 = { z1: 0, z2: 0, x1: 0 };

    let width = plotCanvas.width, height = plotCanvas.height;
    window.addEventListener("resize", () => {
      width = plotCanvas.width; height = plotCanvas.height;
    });

    const FFT_SIZE = 256;
    const SAMPLE_RATE = 500;
    const FREQ_RESOLUTION = SAMPLE_RATE / FFT_SIZE;

    const DELTA_RANGE = [0.5, 4],
      THETA_RANGE = [4, 8],
      ALPHA_RANGE = [8, 12],
      BETA_RANGE = [12, 30],
      GAMMA_RANGE = [30, 45];

    let fftBuffer = new Array(FFT_SIZE).fill(0);
    function normalizeSample(sample) {
      const a = 4096;
      return (sample - a / 2) * (2 / a);
    }

    function applyFilter(input, state) {
      state.x1 = input - (-1.47548044 * state.z1) - (0.58691951 * state.z2);
      const output = 0.02785977 * state.x1 + 0.05571953 * state.z1 + 0.02785977 * state.z2;
      state.z2 = state.z1;
      state.z1 = state.x1;
      return output;
    }

    class FFT {
      constructor(size) {
        this.size = size;
        this.cosTable = new Float32Array(size / 2);
        this.sinTable = new Float32Array(size / 2);
        for (let i = 0; i < size / 2; i++) {
          this.cosTable[i] = Math.cos(-2 * Math.PI * i / size);
          this.sinTable[i] = Math.sin(-2 * Math.PI * i / size);
        }
      }

      computeMagnitudes(input) {
        const real = new Float32Array(this.size);
        const imag = new Float32Array(this.size);
        for (let i = 0; i < input.length && i < this.size; i++) {
          real[i] = input[i];
        }
        this.fft(real, imag);
        const mags = new Float32Array(this.size / 2);
        for (let i = 0; i < this.size / 2; i++) {
          mags[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]) / (this.size / 2);
        }
        return mags;
      }
      fft(real, imag) {
        const n = this.size;
        let j = 0;
        for (let i = 0; i < n - 1; i++) {
          if (i < j) {
            [real[i], real[j]] = [real[j], real[i]];
            [imag[i], imag[j]] = [imag[j], imag[i]];
          }
          let k = n / 2;
          while (k <= j) { j -= k; k /= 2; }
          j += k;
        }
        for (let l = 2; l <= n; l *= 2) {
          const le2 = l / 2;
          for (let k = 0; k < le2; k++) {
            const kth = k * (n / l);
            const c = this.cosTable[kth], s = this.sinTable[kth];
            for (let i = k; i < n; i += l) {
              const i2 = i + le2;
              const tr = c * real[i2] - s * imag[i2];
              const ti = c * imag[i2] + s * real[i2];
              real[i2] = real[i] - tr;
              imag[i2] = imag[i] - ti;
              real[i] += tr;
              imag[i] += ti;
            }
          }
        }
      }
    }

    const fftProcessor = new FFT(FFT_SIZE);

    function calculateBandPower(fftMagnitudes, freqRange) {
      const [startFreq, endFreq] = freqRange;
      const startIndex = Math.max(1, Math.floor(startFreq / FREQ_RESOLUTION));
      const endIndex = Math.min(Math.floor(endFreq / FREQ_RESOLUTION), fftMagnitudes.length - 1);
      let power = 0;
      for (let i = startIndex; i <= endIndex; i++) {
        power += fftMagnitudes[i] * fftMagnitudes[i];
      }
      return power;
    }

    let buffer_size = 128;
    let circular_buffer = new Array(buffer_size).fill(0);
    let data_index = 0, sum = 0;
    function getSmoothedBeta(beta) {
      sum -= circular_buffer[data_index];
      sum += beta;
      circular_buffer[data_index] = beta;
      data_index = (data_index + 1) % buffer_size;
      return sum / buffer_size;
    }

    function updateBarGraph(deltaP, thetaP, alphaP, betaP, gammaP) {
      const total = deltaP + thetaP + alphaP + betaP + gammaP;
      if (total <= 0) return;
      const deltaRel = deltaP / total;
      const thetaRel = thetaP / total;
      const alphaRel = alphaP / total;
      const betaRel = getSmoothedBeta(betaP / total);
      const gammaRel = gammaP / total;

      const normalizedBeta = Math.min(100, betaRel * 100);  // between 0‚Äì100

      console.log("Œ≤-rel:", betaRel.toFixed(3), "Threshold:", betaThreshold.toFixed(3));

      // Focus shooting using dynamic threshold
      if (normalizedBeta >= betaThreshold) {
        console.log("üî• Fire! Œ≤ %:", normalizedBeta.toFixed(2), "‚â•", betaThreshold.toFixed(2));
        if (typeof window.shootBullet === 'function') window.shootBullet();
      }

    }

    function processFFT() {
      const fftMags = fftProcessor.computeMagnitudes(fftBuffer);
      const deltaPower = calculateBandPower(fftMags, DELTA_RANGE);
      const thetaPower = calculateBandPower(fftMags, THETA_RANGE);
      const alphaPower = calculateBandPower(fftMags, ALPHA_RANGE);
      const betaPower = calculateBandPower(fftMags, BETA_RANGE);
      const gammaPower = calculateBandPower(fftMags, GAMMA_RANGE);
      updateBarGraph(deltaPower, thetaPower, alphaPower, betaPower, gammaPower);
    }

    function drawWaveform() {
      if (!plotCanvas || !plotCtx) return; // Safety check

      plotCtx.clearRect(0, 0, plotCanvas.width, plotCanvas.height);

      function drawChannel(data, color) {
        plotCtx.strokeStyle = color;
        plotCtx.lineWidth = 2;
        plotCtx.beginPath();
        for (let i = 0; i < data.length; i++) {
          const x = (i / (data.length - 1)) * plotCanvas.width;
          const y = plotCanvas.height / 2 - (data[i] * gain * (plotCanvas.height / 2));
          if (i === 0) plotCtx.moveTo(x, y);
          else plotCtx.lineTo(x, y);
        }
        plotCtx.stroke();
      }

      // Use default channel if selectedChannel is not defined
      const channel = selectedChannel || "all";

      if (channel === "all" || channel === "ch0") {
        drawChannel(dataCh0, "cyan");
      }
      if (channel === "all" || channel === "ch1") {
        drawChannel(dataCh1, "lime");
      }

      requestAnimationFrame(drawWaveform);
    }
    drawWaveform();

    function updateData(eegValue, dummy) {
      eegValue = notchFilterCh0.process(eegValue, 1);
      dataCh0.push(eegValue);
      dataCh1.push(eegValue);
      if (dataCh0.length > 500) dataCh0.shift();
      if (dataCh1.length > 500) dataCh1.shift();
      fftBuffer.push(eegValue);
      if (fftBuffer.length > FFT_SIZE) fftBuffer.shift();
      if (samplesReceived % 5 === 0) processFFT();
    }

    // Declare variables only once
    const containers = {
      left: document.getElementById('container-left'),
      right: document.getElementById('container-right')
    };
    const sliders = {
      left: document.getElementById('lower-left'),
      right: document.getElementById('lower-right')
    };
    const output = document.getElementById('output');

    let activeSlider = null;
    let currentValues = { left: 50, right: 50 }; // Initial threshold values (50%)

    function processSample(dataView) {
      if (dataView.byteLength !== SINGLE_SAMPLE_LEN) return;

      const sampleCounter = dataView.getUint8(0);
      prevSampleCounter = sampleCounter;
      const rawEEG = dataView.getInt16(1, false);

      // Process EEG as before
      const normEEG = normalizeSample(Math.max(0, Math.min(4095, rawEEG)));
      const filteredEEG = applyFilter(normEEG, filterStateCh0);
      updateData(filteredEEG, filteredEEG);
      samplesReceived++;

      // Read EMG data from BLE device
      const rawEMGLeft = dataView.getInt16(3, false);
      const rawEMGRight = dataView.getInt16(5, false);

      // Apply 45Hz high-pass filter
      const filteredEMGLeft = EMGFilterLeft.process(rawEMGLeft);
      const filteredEMGRight = EMGFilterRight.process(rawEMGRight);

      // Apply envelope detection
      const envLeft = envelopeFilterLeft.getEnvelope(Math.abs(filteredEMGLeft));
      const envRight = envelopeFilterRight.getEnvelope(Math.abs(filteredEMGRight));

      // Update live display
      const emgLeftLive = document.getElementById('emgLeftLive');
      const emgRightLive = document.getElementById('emgRightLive');
      if (emgLeftLive) emgLeftLive.textContent = envLeft.toFixed(1);
      if (emgRightLive) emgRightLive.textContent = envRight.toFixed(1);

      console.log(
        "rawL:", rawEMGLeft,
        "filteredL:", filteredEMGLeft.toFixed(2),
        "envL:", envLeft.toFixed(2),
        "threshL:", emgLeftThreshold,
        "| rawR:", rawEMGRight,
        "filteredR:", filteredEMGRight.toFixed(2),
        "envR:", envRight.toFixed(2),
        "threshR:", emgRightThreshold
      );

      // Use slider thresholds for EMG control
      if (envLeft > emgLeftThreshold && envLeft > envRight) {
        player.dx = -player.speed;
        console.log("üèÉ Moving LEFT - envL:", envLeft.toFixed(2), "> threshold:", emgLeftThreshold);
      } else if (envRight > emgRightThreshold && envRight > envLeft) {
        player.dx = player.speed;
        console.log("üèÉ Moving RIGHT - envR:", envRight.toFixed(2), "> threshold:", emgRightThreshold);
      } else {
        player.dx = 0;
      }
    }


    function handleNotification(event) {
      const value = event.target.value;
      if (value.byteLength === NEW_PACKET_LEN) {
        for (let i = 0; i < NEW_PACKET_LEN; i += SINGLE_SAMPLE_LEN) {
          const sampleBuf = value.buffer.slice(i, i + SINGLE_SAMPLE_LEN);
          processSample(new DataView(sampleBuf));
        }
      } else if (value.byteLength === SINGLE_SAMPLE_LEN) {
        processSample(new DataView(value.buffer));
      }
    }

    window.onload = function () {
      const connectBtn = document.getElementById("connectBtn");
      const disconnectBtn = document.getElementById("disconnectBtn");
      const startBtn = document.getElementById("startBtn");
      const stopBtn = document.getElementById("stopBtn");
      const gainSlider = document.getElementById("gainSlider");
      const channelSelector = document.getElementById("channelSelector");

      let device = null, server = null, controlChar = null, dataChar = null;
      let streaming = false, connected = false;

      function updateButtonStates() {
        connectBtn.disabled = connected || streaming;
        disconnectBtn.disabled = !connected;
        startBtn.disabled = !connected || streaming;
        stopBtn.disabled = !streaming;
        channelSelector.disabled = !connected;
        gainSlider.disabled = !connected;

        const statusEl = document.getElementById("statusText");
        if (!connected) statusEl.textContent = "Not connected";
        else if (!streaming) statusEl.textContent = "Connected but not streaming";
        else statusEl.textContent = "Connected and streaming data";
      }

      async function connectBLE() {
        try {
          if (!navigator.bluetooth) {
            alert("Web Bluetooth API not available.");
            return;
          }
          device = await navigator.bluetooth.requestDevice({
            filters: [{ namePrefix: "NPG" }],
            optionalServices: ["4fafc201-1fb5-459e-8fcc-c5c9c331914b"],
          });
          server = await device.gatt.connect();
          const service = await server.getPrimaryService("4fafc201-1fb5-459e-8fcc-c5c9c331914b");
          controlChar = await service.getCharacteristic("0000ff01-0000-1000-8000-00805f9b34fb");
          dataChar = await service.getCharacteristic("beb5483e-36e1-4688-b7f5-ea07361b26a8");

          connected = true;
          streaming = false;
          updateButtonStates();
          console.log("Device connected.");
        } catch (err) {
          console.error("Connection error:", err);
          alert("Failed to connect: " + err.message);
        }
      }

      async function disconnectBLE() {
        try {
          if (device && device.gatt.connected) {
            if (streaming) await stopStream();
            device.gatt.disconnect();
          }
          connected = false;
          streaming = false;
          updateButtonStates();
        } catch (err) {
          console.error("Disconnect error:", err);
        }
      }

      async function startStream() {
        try {
          await controlChar.writeValue(new TextEncoder().encode("START"));
          await dataChar.startNotifications();
          dataChar.addEventListener("characteristicvaluechanged", handleNotification);
          streaming = true;
          updateButtonStates();
        } catch (err) {
          alert("Failed to start streaming: " + err.message);
        }
      }

      async function stopStream() {
        try {
          await dataChar.stopNotifications();
          dataChar.removeEventListener("characteristicvaluechanged", handleNotification);
          streaming = false;
          updateButtonStates();
        } catch (err) {
          console.error("Stop error:", err);
        }
      }

      // Assign event listeners after DOM is ready
      connectBtn.addEventListener("click", connectBLE);
      disconnectBtn.addEventListener("click", disconnectBLE);
      startBtn.addEventListener("click", startStream);
      stopBtn.addEventListener("click", stopStream);
    };

  </script>

</body>

</html>