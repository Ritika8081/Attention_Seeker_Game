<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>EEG + Game Single Screen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
</head>

<body>
  <!-- Show actual game interface immediately -->
  <div id="mainContainer">
    <div id="contentContainer">
      <!-- Left column: Game -->
      <div id="gameSection">
        <canvas id="gameCanvas"></canvas>
      </div>

      <!-- Settings Button - Always visible -->
      <button id="settingsBtn" title="Settings"><i class="fas fa-cog"></i></button>

      <!-- Settings Modal -->
      <div id="settingsModal" class="modal">
        <div class="modal-content">
          <span class="close-modal">&times;</span>
          <h2><i class="fas fa-sliders-h"></i> Controls</h2>
          <div class="controls-group">
            <button id="connectBtn" class="btn"><i class="fas fa-plug"></i> Connect</button>
            <button id="disconnectBtn" class="btn"><i class="fas fa-unlink"></i> Disconnect</button>
            <button id="startBtn" class="btn"><i class="fas fa-play"></i> Start</button>
            <button id="stopBtn" class="btn"><i class="fas fa-stop"></i> Stop</button>
            <select id="channelSelector" style="display: none;">
              <option value="all">All Channels</option>
              <option value="ch0">Channel 0</option>
              <option value="ch1">Channel 1</option>
              <option value="ch2">Channel 2</option>
            </select>
            <canvas id="plotCanvas" style="display: none;"></canvas>

            <div class="slider-wrapper" style="display: none;">
              <label for="gainSlider"><i class="fas fa-sliders-h"></i> Gain:</label>
              <input type="range" id="gainSlider" min="0.1" max="5" step="0.1" value="1">
            </div>
          </div>
          <div id="statusText"><i class="fas fa-circle-notch fa-spin"></i> Waiting for connection...</div>

          <hr style="margin: 30px 0; border-color: rgba(255,255,255,0.1);">

          <h2><i class="fas fa-brain"></i> Beta Threshold Calibration</h2>
          <div class="threshold-control">
            <div id="calibrationStatus"><i class="fas fa-hourglass-half"></i> Click to start calibration</div>
            <div style="margin-top: 10px;">Threshold: <strong id="betaThresholdValue">--</strong></div>
            <div id="calibrationTimer" style="font-size: 1.5rem; margin-top: 0.5rem;"></div>
          </div>
          <button id="calibrateBtn" class="btn" onclick="startCalibration()" style="margin-top: 12px;">
            <i class="fas fa-sync-alt"></i> Calibrate Now
          </button>

          <!-- <hr style="margin: 30px 0; border-color: rgba(255,255,255,0.1);">

          <h2><i class="fas fa-dumbbell"></i> EMG Sliders</h2> -->
          <div class="slider-container" style="display: none;">
            <div>
              <div class="container" id="container-left">
                <div class="slider" id="lower-left"></div>
              </div>
              <div class="slider-label"><i class="fas fa-hand-point-left"></i> Left Threshold: <span
                  id="leftEMGThresholdValue">--</span></div>
            </div>
            <div>
              <div class="container" id="container-right">
                <div class="slider" id="lower-right"></div>
              </div>
              <div class="slider-label"><i class="fas fa-hand-point-right"></i> Right Threshold: <span
                  id="rightEMGThresholdValue">--</span></div>
            </div>
          </div>
          <div style="margin-top: 1rem; display: none;">
            <div id="emgCalibrationStatus"><i class="fas fa-info-circle"></i> Click below to calibrate</div>
            <div id="emgCalibrationTimer" style="font-weight: bold; margin: 6px 0;"></div>
            <button onclick="startEMGCalibration()" class="btn" style="margin-top: 8px;">
              <i class="fas fa-bolt"></i> Calibrate EMG
            </button>
          </div>
          <div id="output" class="threshold-output"></div>
        </div>
      </div>

    </div>
  </div>
  <!-- Game JS -->
  <script>
    // ============ GAME CODE ============
    const gameCanvas = document.getElementById("gameCanvas");
    const gctx = gameCanvas.getContext("2d");

    // Player spaceship with responsive positioning
    const player = {
      x: 0,
      y: 0,
      speed: 5,
      dx: 0,
      dy: 0,
      width: 50,
      height: 50
    };

    const spaceshipImg = new Image();
    spaceshipImg.src = "assets/spaceship.png";

    function setPlayerPosition() {
      // Center horizontally
      player.x = (gameCanvas.width - player.width) / 2;
      // Position near bottom with some padding
      player.y = gameCanvas.height - player.height - 80;
    }

    function resizeGameCanvas() {
      gameCanvas.width = window.innerWidth;
      gameCanvas.height = window.innerHeight;

      // Responsive spaceship sizing
      const baseWidth = Math.min(250, gameCanvas.width * 0.12); // 12% of screen width
      player.width = baseWidth;

      if (spaceshipImg.complete && spaceshipImg.naturalWidth > 0) {
        const aspectRatio = spaceshipImg.width / spaceshipImg.height;
        player.height = player.width / aspectRatio;
      } else {
        player.height = baseWidth; // Fallback square ratio
      }

      setPlayerPosition();
    }

    spaceshipImg.onload = () => {
      const aspectRatio = spaceshipImg.width / spaceshipImg.height;
      player.height = player.width / aspectRatio;
      setPlayerPosition();
    };

    // Initialize and handle resize
    window.addEventListener("resize", resizeGameCanvas);
    resizeGameCanvas();

    let emgLeftMaxRef = 1;
    let emgRightMaxRef = 1;


    let betaBuffer = [];
    let isCalibrating = false;
    let betaThreshold = 0.4;
    let calibrationInterval = null;
    let calibrationStartTime = null;
    let isEMGCalibrating = false;
    let emgLeftBuffer = [];
    let emgRightBuffer = [];
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const closeModal = document.querySelector('.close-modal');
    let emgLeftThreshold = 100;
    let emgRightThreshold = 100;
    let envLeft = 0;
    let envRight = 0;
    const EMG_MAX_REF = 3000; // Can be adjusted based on your signal amplitude

    // Preload custom asteroid images (asteroid1.png ... asteroid14.png)
    const asteroidImages = [];
    for (let i = 1; i <= 14; i++) {
      const img = new Image();
      img.src = `assets/asteroids/asteroid${i}.png`;
      asteroidImages.push(img);
    }

    // Background objects (stars, planets)
    const stars = [];
    const planets = [];
    for (let i = 0; i < 100; i++) {
      stars.push({
        x: Math.random() * gameCanvas.width,
        y: Math.random() * gameCanvas.height,
        radius: Math.random() * 2 + 1,
        speed: Math.random() * 2 + 0.5
      });
    }

    settingsBtn.addEventListener('click', () => {
      settingsModal.style.display = 'block';
    });

    closeModal.addEventListener('click', () => {
      settingsModal.style.display = 'none';
    });

    window.addEventListener('click', (e) => {
      if (e.target === settingsModal) {
        settingsModal.style.display = 'none';
      }
    });


    function startCalibration() {
      betaBuffer = [];
      isCalibrating = true;
      document.getElementById('calibrationStatus').innerHTML = `<i class="fas fa-spinner fa-spin"></i> Calibrating...`;
      document.getElementById('betaThresholdValue').textContent = "--";

      let secondsLeft = 5;
      const timerDisplay = document.getElementById('calibrationTimer');
      timerDisplay.textContent = `${secondsLeft}s`;

      const countdown = setInterval(() => {
        secondsLeft--;
        if (secondsLeft > 0) {
          timerDisplay.textContent = `${secondsLeft}s`;
        } else {
          clearInterval(countdown);
          timerDisplay.textContent = '';
        }
      }, 1000);

      setTimeout(() => {
        isCalibrating = false;
        if (betaBuffer.length > 0) {
          const max = Math.max(...betaBuffer);
          betaThreshold = max * 0.7;
          document.getElementById('betaThresholdValue').textContent = betaThreshold.toFixed(3);
          document.getElementById('calibrationStatus').innerHTML = `<i class="fas fa-check-circle"></i> Calibrated`;
        } else {
          document.getElementById('betaThresholdValue').textContent = "0.000";
          document.getElementById('calibrationStatus').innerHTML = `<i class="fas fa-exclamation-triangle"></i> No beta data`;
        }
      }, 5000);
    }

    function updateBackground() {
      stars.forEach(star => {
        star.y += star.speed;
        if (star.y > gameCanvas.height) {
          star.y = 0;
          star.x = Math.random() * gameCanvas.width;
        }
      });

    }
    function startEMGCalibration() {
      emgLeftBuffer.length = 0;
      emgRightBuffer.length = 0;
      isEMGCalibrating = true;

      document.getElementById('emgCalibrationStatus').innerHTML = `<i class="fas fa-spinner fa-spin"></i> Calibrating...`;

      setTimeout(() => {
        isEMGCalibrating = false;

        if (emgLeftBuffer.length && emgRightBuffer.length) {
          emgLeftMaxRef = Math.max(...emgLeftBuffer);
          emgRightMaxRef = Math.max(...emgRightBuffer);

          emgLeftThreshold = 0.7;  // 70% of max effort
          emgRightThreshold = 0.7;

          document.getElementById('leftEMGThresholdValue').textContent = (emgLeftThreshold * 100).toFixed(2) + '%';
          document.getElementById('rightEMGThresholdValue').textContent = (emgRightThreshold * 100).toFixed(2) + '%';
          document.getElementById('emgCalibrationStatus').innerHTML = `<i class="fas fa-check-circle"></i> Calibrated`;

          console.log("ðŸŽ¯ EMG Calibration Summary:");
          console.log(`Left max: ${emgLeftMaxRef.toFixed(2)} â†’ Threshold: 70%`);
          console.log(`Right max: ${emgRightMaxRef.toFixed(2)} â†’ Threshold: 70%`);
        } else {
          document.getElementById('leftEMGThresholdValue').textContent = "--";
          document.getElementById('rightEMGThresholdValue').textContent = "--";
          document.getElementById('emgCalibrationStatus').innerHTML = `<i class="fas fa-exclamation-triangle"></i> No EMG data`;
        }

        emgLeftBuffer.length = 0;
        emgRightBuffer.length = 0;
      }, 5000);
    }

    // Nebula effect
    let nebulaColor1 = { r: 50, g: 0, b: 150 };
    let nebulaColor2 = { r: 0, g: 0, b: 100 };
    function updateNebulaColors() {
      const t = Date.now();

      // Violet-magenta base (nebulaColor1)
      nebulaColor1.r = 40 + Math.sin(t * 0.0002) * 30; // Reddish-magenta (40â€“70)
      nebulaColor1.g = 0;                             // Keep dark (optional: try 10â€“20 for subtle green)
      nebulaColor1.b = 60 + Math.cos(t * 0.00015) * 40; // Bluish glow (20â€“100)

      // Blue-teal highlight (nebulaColor2)
      nebulaColor2.r = 0;
      nebulaColor2.g = 20 + Math.sin(t * 0.00025) * 20; // Teal-greenish (0â€“40)
      nebulaColor2.b = 40 + Math.sin(t * 0.0003) * 30;  // Deep blue (10â€“70)
    }


    function drawBackground() {
      updateNebulaColors();
      let gradient = gctx.createLinearGradient(0, 0, gameCanvas.width, gameCanvas.height);
      const clamp = (value, max = 50) => Math.min(Math.abs(value) % 256, max);

      gradient.addColorStop(
        0,
        `rgb(${clamp(nebulaColor1.r)}, 0, ${clamp(nebulaColor1.b)})`
      );
      gradient.addColorStop(
        1,
        `rgb(0, ${clamp(nebulaColor2.g)}, ${clamp(nebulaColor2.b)})`
      );

      gctx.fillStyle = gradient;
      gctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

      // Stars
      gctx.fillStyle = "white";
      stars.forEach(star => {
        gctx.beginPath();
        gctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
        gctx.fill();
      });

      // Planets
      gctx.fillStyle = "rgba(100, 100, 255, 0.8)";
      planets.forEach(planet => {
        gctx.beginPath();
        gctx.arc(planet.x, planet.y, planet.size, 0, Math.PI * 2);
        gctx.fill();
      });
    }
    class EMGFilter {
      constructor() {
        // Internal filter state
        this.z1 = 0;
        this.z2 = 0;
        this.x1 = 0;
      }

      /**
       * Process one sample through the 70â€¯Hz biquad section.
       * @param {number} input Raw EMG sample
       * @returns {number} Filtered output
       */
      process(input) {
       
        // (coefficients for 500â€¯Hz sampling, 70â€¯Hz center)
        this.x1 = input - (-0.82523238 * this.z1) - (0.29463653 * this.z2);

        // Compute filter output from SOS coefficients
        const output =
          0.52996723 * this.x1 +
          -1.05993445 * this.z1 +
          0.52996723 * this.z2;

        // Shift the delay elements
        this.z2 = this.z1;
        this.z1 = this.x1;

        return output;
      }
    }

    const EMGFilterLeft = new EMGFilter();
    const EMGFilterRight = new EMGFilter();

    // ---------------- Added Envelope Filter for EMG Data ----------------
    class EnvelopeFilter {
      constructor(bufferSize) {
        this.bufferSize = bufferSize;
        this.circularBuffer = new Array(bufferSize).fill(0);
        this.sum = 0;
        this.dataIndex = 0;
      }

      getEnvelope(absEmg) {
        this.sum -= this.circularBuffer[this.dataIndex];
        this.sum += absEmg;
        this.circularBuffer[this.dataIndex] = absEmg;
        this.dataIndex = (this.dataIndex + 1) % this.bufferSize;
        return this.sum / this.bufferSize;
      }
    }
    // Create envelope filters for each EMG channel
    const envelopeFilterLeft = new EnvelopeFilter(64);
    const envelopeFilterRight = new EnvelopeFilter(64);

    document.addEventListener("keydown", (event) => {
      if (event.key === "ArrowLeft") player.dx = -player.speed;
      if (event.key === "ArrowRight") player.dx = player.speed;
      if (event.key === "ArrowUp") player.dy = -player.speed;
      if (event.key === "ArrowDown") player.dy = player.speed;
    });
    document.addEventListener("keyup", () => {
      player.dx = 0;
      player.dy = 0;
    });

    function updatePlayer() {
      player.x += player.dx;
      player.y += player.dy;
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > gameCanvas.width) player.x = gameCanvas.width - player.width;
      if (player.y < 0) player.y = 0;
      if (player.y + player.height > gameCanvas.height) player.y = gameCanvas.height - player.height;
    }

    function drawPlayer() {
      if (spaceshipImg.complete) {
        gctx.drawImage(spaceshipImg, player.x, player.y, player.width, player.height);
      }
    }

    // Enemies
    const enemies = [];
    // Enhanced enemy spawning with limit
    const MAX_ENEMIES = 10; // Limit number of enemies on screen

    function spawnEnemy() {
      // Don't spawn if game is paused or too many enemies exist
      if (!gameRunning || !isPageVisible || enemies.length >= MAX_ENEMIES) {
        return;
      }

      const enemySize = 130;
      const randomIndex = Math.floor(Math.random() * asteroidImages.length);

      enemies.push({
        x: Math.random() * (gameCanvas.width - enemySize),
        y: -enemySize,
        width: enemySize,
        height: enemySize,
        speed: 2,
        image: asteroidImages[randomIndex],
        spawnTime: performance.now() // Track when enemy was spawned
      });
    }

    function updateEnemies() {
      enemies.forEach((enemy, i) => {
        enemy.y += enemy.speed;
        if (enemy.y > gameCanvas.height) enemies.splice(i, 1);
      });
    }
    function drawEnemies() {
      enemies.forEach(enemy => {
        if (enemy.image && enemy.image.complete) {
          gctx.drawImage(enemy.image, enemy.x, enemy.y, enemy.width, enemy.height);
        } else {
          // Fallback if image not loaded yet
          gctx.fillStyle = "red";
          gctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
        }
      });
    }

    // Bullets
    const bullets = [];
    function shootBullet() {
      bullets.push({
        x: player.x + player.width / 2 - 5,
        y: player.y,
        width: 10,
        height: 20,
        speed: 5
      });
    }
    // Expose globally so EEG code can call it
    window.shootBullet = shootBullet;

    function updateBullets() {
      bullets.forEach((bullet, i) => {
        bullet.y -= bullet.speed;
        if (bullet.y < 0) bullets.splice(i, 1);
      });
    }
    function drawBullets() {
      gctx.fillStyle = "yellow";
      bullets.forEach(bullet => {
        gctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
      });
    }

    function checkCollisions() {
      bullets.forEach((bullet, bIndex) => {
        enemies.forEach((enemy, eIndex) => {
          if (
            bullet.x < enemy.x + enemy.width &&
            bullet.x + bullet.width > enemy.x &&
            bullet.y < enemy.y + enemy.height &&
            bullet.y + bullet.height > enemy.y
          ) {
            enemies.splice(eIndex, 1);
            bullets.splice(bIndex, 1);
          }
        });
      });
    }

    // Add this code after your existing game variables
    let gameRunning = true;
    let lastTime = 0;
    let enemySpawnInterval = null;

    // Page Visibility API to detect when tab is hidden/visible
    let isPageVisible = !document.hidden;

    function handleVisibilityChange() {
      if (document.hidden) {
        // Page is hidden - pause the game
        pauseGame();
      } else {
        // Page is visible - resume the game
        resumeGame();
      }
    }

    function pauseGame() {
      console.log("ðŸŽ® Game Paused - Tab Hidden");
      gameRunning = false;
      isPageVisible = false;

      // Clear enemy spawn interval
      if (enemySpawnInterval) {
        clearInterval(enemySpawnInterval);
        enemySpawnInterval = null;
      }
    }

    function resumeGame() {
      console.log("ðŸŽ® Game Resumed - Tab Visible");
      gameRunning = true;
      isPageVisible = true;
      lastTime = performance.now(); // Reset timing

      // Restart enemy spawning
      startEnemySpawning();
    }

    // Enhanced enemy spawning with proper interval management
    function startEnemySpawning() {
      // Clear any existing interval first
      if (enemySpawnInterval) {
        clearInterval(enemySpawnInterval);
      }

      // Start new interval only if game is running
      if (gameRunning && isPageVisible) {
        enemySpawnInterval = setInterval(() => {
          if (gameRunning && isPageVisible) {
            spawnEnemy();
          }
        }, 2000);
      }
    }

    // Enhanced game loop with visibility check
    function gameLoop(currentTime) {
      // Only run game logic if page is visible and game is running
      if (!gameRunning || !isPageVisible) {
        requestAnimationFrame(gameLoop);
        return;
      }

      // Calculate delta time for smooth animation
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;

      // Skip frame if delta time is too large (tab was hidden)
      if (deltaTime > 100) {
        requestAnimationFrame(gameLoop);
        return;
      }

      gctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
      updateBackground();
      drawBackground();
      updatePlayer();
      updateEnemies();
      updateBullets();
      checkCollisions();
      drawPlayer();
      drawEnemies();
      drawBullets();

      requestAnimationFrame(gameLoop);
    }

    // Enhanced enemy update with bounds checking
    function updateEnemies() {
      enemies.forEach((enemy, i) => {
        if (gameRunning && isPageVisible) {
          enemy.y += enemy.speed;

          // Remove enemies that are off screen
          if (enemy.y > gameCanvas.height + enemy.height) {
            enemies.splice(i, 1);
          }
        }
      });
    }

    // Enhanced bullet update
    function updateBullets() {
      bullets.forEach((bullet, i) => {
        if (gameRunning && isPageVisible) {
          bullet.y -= bullet.speed;

          // Remove bullets that are off screen
          if (bullet.y < -bullet.height) {
            bullets.splice(i, 1);
          }
        }
      });
    }

    // Add event listeners for visibility change
    document.addEventListener('visibilitychange', handleVisibilityChange);

    // Also handle window focus/blur as backup
    window.addEventListener('focus', () => {
      if (!isPageVisible) resumeGame();
    });

    window.addEventListener('blur', () => {
      if (isPageVisible) pauseGame();
    });

    // Initialize the game properly
    function initializeGame() {
      lastTime = performance.now();
      startEnemySpawning();
      gameLoop(lastTime);
    }

  // Resize canvas to match layout
resizeGameCanvas();

// Set up background before game loop starts
updateNebulaColors();     // sets color values
updateBackground();       // applies motion if you use it
drawBackground();         // draws dark galaxy gradient

// Draw static frame of game
if (player) drawPlayer();
if (enemies) drawEnemies();
if (bullets) drawBullets();


    initializeGame();

  </script>


  <!-- EEG + BLE Code -->
  <script>
    // ============ EEG CODE ============
    class Notch {
      constructor() {
        this.z1_1 = 0; this.z2_1 = 0;
        this.x_1 = 0;
        this.currentSamplingRate = 500;
      }
      setSamplingRate(rate) { this.currentSamplingRate = rate; }
      process(input, type) {
        if (!type) return input;
        let output = input;
        // Simple example: 50Hz notch for 500Hz
        if (this.currentSamplingRate === 500 && type === 1) {
          this.x_1 = output - (-1.56858163 * this.z1_1) - (0.96424138 * this.z2_1);
          output = 0.96508099 * this.x_1 + -1.56202714 * this.z1_1 + 0.96508099 * this.z2_1;
          this.z2_1 = this.z1_1;
          this.z1_1 = this.x_1;
        }
        return output;
      }
    }

    let notchFilterCh0 = new Notch();
    let notchFilterCh1 = new Notch();
    notchFilterCh0.setSamplingRate(500);
    notchFilterCh1.setSamplingRate(500);

    let device = null, server = null, controlChar = null, dataChar = null;
    let streaming = false, connected = false;

    const SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
    const DATA_CHAR_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
    const CONTROL_CHAR_UUID = "0000ff01-0000-1000-8000-00805f9b34fb";
    const SINGLE_SAMPLE_LEN = 7, BLOCK_COUNT = 10;
    const NEW_PACKET_LEN = SINGLE_SAMPLE_LEN * BLOCK_COUNT;

    let prevSampleCounter = null, samplesReceived = 0;
    const THRESHOLD = 0.5;
    let lastActionTime = 0;
    const DEBOUNCE_TIME = 1000;

    // Plot canvas for EEG waveform (renamed context variable to avoid collision)
    const plotCanvas = document.getElementById("plotCanvas");
    const plotCtx = plotCanvas.getContext("2d");
    function resizePlotCanvas() {
      plotCanvas.width = plotCanvas.clientWidth;
      plotCanvas.height = plotCanvas.clientHeight;
    }
    window.addEventListener("resize", resizePlotCanvas);
    resizePlotCanvas();

    let dataCh0 = new Array(500).fill(0);
    let dataCh1 = new Array(500).fill(0);

    let filterStateCh0 = { z1: 0, z2: 0, x1: 0 };
    let filterStateCh1 = { z1: 0, z2: 0, x1: 0 };

    let gain = 1;
    const gainSlider = document.getElementById("gainSlider");
    gainSlider.disabled = true;  // disable until connected
    gainSlider.addEventListener("input", (e) => {
      gain = parseFloat(e.target.value);
    });

    let selectedChannel = "all";
    const channelSelector = document.getElementById("channelSelector");
    channelSelector.disabled = true;
    channelSelector.addEventListener("change", (e) => {
      selectedChannel = e.target.value;
    });

    let width = plotCanvas.width, height = plotCanvas.height;
    window.addEventListener("resize", () => {
      width = plotCanvas.width; height = plotCanvas.height;
    });

    const FFT_SIZE = 256;
    const SAMPLE_RATE = 500;
    const FREQ_RESOLUTION = SAMPLE_RATE / FFT_SIZE;

    const DELTA_RANGE = [0.5, 4],
      THETA_RANGE = [4, 8],
      ALPHA_RANGE = [8, 12],
      BETA_RANGE = [12, 30],
      GAMMA_RANGE = [30, 45];

    let fftBuffer = new Array(FFT_SIZE).fill(0);
    function normalizeSample(sample) {
      const a = 4096;
      return (sample - a / 2) * (2 / a);
    }

    function applyFilter(input, state) {
      state.x1 = input - (-1.47548044 * state.z1) - (0.58691951 * state.z2);
      const output = 0.02785977 * state.x1 + 0.05571953 * state.z1 + 0.02785977 * state.z2;
      state.z2 = state.z1;
      state.z1 = state.x1;
      return output;
    }

    class FFT {
      constructor(size) {
        this.size = size;
        this.cosTable = new Float32Array(size / 2);
        this.sinTable = new Float32Array(size / 2);
        for (let i = 0; i < size / 2; i++) {
          this.cosTable[i] = Math.cos(-2 * Math.PI * i / size);
          this.sinTable[i] = Math.sin(-2 * Math.PI * i / size);
        }
      }
      computeMagnitudes(input) {
        const real = new Float32Array(this.size);
        const imag = new Float32Array(this.size);
        for (let i = 0; i < input.length && i < this.size; i++) {
          real[i] = input[i];
        }
        this.fft(real, imag);
        const mags = new Float32Array(this.size / 2);
        for (let i = 0; i < this.size / 2; i++) {
          mags[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]) / (this.size / 2);
        }
        return mags;
      }
      fft(real, imag) {
        const n = this.size;
        let j = 0;
        for (let i = 0; i < n - 1; i++) {
          if (i < j) {
            [real[i], real[j]] = [real[j], real[i]];
            [imag[i], imag[j]] = [imag[j], imag[i]];
          }
          let k = n / 2;
          while (k <= j) { j -= k; k /= 2; }
          j += k;
        }
        for (let l = 2; l <= n; l *= 2) {
          const le2 = l / 2;
          for (let k = 0; k < le2; k++) {
            const kth = k * (n / l);
            const c = this.cosTable[kth], s = this.sinTable[kth];
            for (let i = k; i < n; i += l) {
              const i2 = i + le2;
              const tr = c * real[i2] - s * imag[i2];
              const ti = c * imag[i2] + s * real[i2];
              real[i2] = real[i] - tr;
              imag[i2] = imag[i] - ti;
              real[i] += tr;
              imag[i] += ti;
            }
          }
        }
      }
    }

    const fftProcessor = new FFT(FFT_SIZE);

    function calculateBandPower(fftMagnitudes, freqRange) {
      const [startFreq, endFreq] = freqRange;
      const startIndex = Math.max(1, Math.floor(startFreq / FREQ_RESOLUTION));
      const endIndex = Math.min(Math.floor(endFreq / FREQ_RESOLUTION), fftMagnitudes.length - 1);
      let power = 0;
      for (let i = startIndex; i <= endIndex; i++) {
        power += fftMagnitudes[i] * fftMagnitudes[i];
      }
      return power;
    }


    let buffer_size = 128;
    let circular_buffer = new Array(buffer_size).fill(0);
    let data_index = 0, sum = 0;
    function getSmoothedBeta(beta) {
      sum -= circular_buffer[data_index];
      sum += beta;
      circular_buffer[data_index] = beta;
      data_index = (data_index + 1) % buffer_size;
      return sum / buffer_size;
    }

    function updateBarGraph(deltaP, thetaP, alphaP, betaP, gammaP) {
      const total = deltaP + thetaP + alphaP + betaP + gammaP;
      if (total <= 0) return;
      const deltaRel = deltaP / total;
      const thetaRel = thetaP / total;
      const alphaRel = alphaP / total;
      const betaRel = getSmoothedBeta(betaP / total);
      const gammaRel = gammaP / total;


      const normalizedBeta = Math.min(100, betaRel * 100);  // between 0â€“100

      if (isCalibrating) {
        betaBuffer.push(normalizedBeta);
        console.log("Captured Beta %:", normalizedBeta.toFixed(2));
      }

      console.log("Î²-rel:", betaRel.toFixed(3), "Threshold:", betaThreshold.toFixed(3));

      // Focus shooting using dynamic threshold
      if (normalizedBeta >= betaThreshold) {
        console.log("ðŸ”¥ Fire! Î² %:", normalizedBeta.toFixed(2), "â‰¥", betaThreshold.toFixed(2));
        if (typeof window.shootBullet === 'function') window.shootBullet();
      }


    }

    function processFFT() {
      const fftMags = fftProcessor.computeMagnitudes(fftBuffer);
      const deltaPower = calculateBandPower(fftMags, DELTA_RANGE);
      const thetaPower = calculateBandPower(fftMags, THETA_RANGE);
      const alphaPower = calculateBandPower(fftMags, ALPHA_RANGE);
      const betaPower = calculateBandPower(fftMags, BETA_RANGE);
      const gammaPower = calculateBandPower(fftMags, GAMMA_RANGE);
      updateBarGraph(deltaPower, thetaPower, alphaPower, betaPower, gammaPower);
    }

    function drawWaveform() {
      plotCtx.clearRect(0, 0, plotCanvas.width, plotCanvas.height);
      function drawChannel(data, color) {
        plotCtx.strokeStyle = color;
        plotCtx.lineWidth = 2;
        plotCtx.beginPath();
        for (let i = 0; i < data.length; i++) {
          const x = (i / (data.length - 1)) * plotCanvas.width;
          const y = plotCanvas.height / 2 - (data[i] * gain * (plotCanvas.height / 2));
          if (i === 0) plotCtx.moveTo(x, y);
          else plotCtx.lineTo(x, y);
        }
        plotCtx.stroke();
      }
      if (selectedChannel === "all" || selectedChannel === "ch0") {
        drawChannel(dataCh0, "cyan");
      }
      if (selectedChannel === "all" || selectedChannel === "ch1") {
        drawChannel(dataCh1, "lime");
      }
      requestAnimationFrame(drawWaveform);
    }
    drawWaveform();

    function updateData(eegValue, dummy) {
      eegValue = notchFilterCh0.process(eegValue, 1);
      dataCh0.push(eegValue);
      dataCh1.push(eegValue);
      if (dataCh0.length > 500) dataCh0.shift();
      if (dataCh1.length > 500) dataCh1.shift();
      fftBuffer.push(eegValue);
      if (fftBuffer.length > FFT_SIZE) fftBuffer.shift();
      if (samplesReceived % 5 === 0) processFFT();
    }

    // Declare variables only once
    const containers = {
      left: document.getElementById('container-left'),
      right: document.getElementById('container-right')
    };
    const sliders = {
      left: document.getElementById('lower-left'),
      right: document.getElementById('lower-right')
    };
    const output = document.getElementById('output');

    let activeSlider = null;
    let currentValues = { left: 50, right: 50 }; // Initial threshold values (50%)

    // Updated processSample: Now reads 3 channels (EEG at offset 1, EMG left at offset 3, EMG right at offset 5)
    // const highPass45Left = new HighPassFilter45Hz(500);
    // const highPass45Right = new HighPassFilter45Hz(500);

    function processSample(dataView) {
      if (dataView.byteLength !== SINGLE_SAMPLE_LEN) return;

      const sampleCounter = dataView.getUint8(0);
      prevSampleCounter = sampleCounter;
      // Read EEG and EMG channels
      const rawEEG = dataView.getInt16(1, false);


      // Process EEG as before
      const normEEG = normalizeSample(Math.max(0, Math.min(4095, rawEEG)));
      const filteredEEG = applyFilter(normEEG, filterStateCh0);
      updateData(filteredEEG, filteredEEG);
      samplesReceived++;
      // Read EMG data from BLE device
      const rawEMGLeft = dataView.getInt16(3, false);
      const rawEMGRight = dataView.getInt16(5, false);

      // Apply 45Hz high-pass filter
      const filteredEMGLeft = EMGFilterLeft.process(rawEMGLeft);
      const filteredEMGRight = EMGFilterRight.process(rawEMGRight);


      // Apply envelope detection
      const envLeft = envelopeFilterLeft.getEnvelope(Math.abs(filteredEMGLeft));
      const envRight = envelopeFilterRight.getEnvelope(Math.abs(filteredEMGRight));


      if (isEMGCalibrating) {
        emgLeftBuffer.push(envLeft);
        emgRightBuffer.push(envRight);
      }

      console.log(
        "rawL:", rawEMGLeft,
        "filteredL:", filteredEMGLeft,
        "envL:", envLeft,
        "| rawR:", rawEMGRight,
        "filteredR:", filteredEMGRight.toFixed(2),
        "envR:", envRight.toFixed(2)
      );

      if (envLeft > 100 && envLeft > envRight) {
        player.dx = -player.speed;
      } else if (envRight > 100 && envRight > envLeft) {
        player.dx = player.speed;
      } else {
        player.dx = 0;
      }

      // Optional log
      // console.log(
      //   `envL: ${envLeft.toFixed(2)} (${(normEnvLeft * 100).toFixed(2)}%)`,
      //   `envR: ${envRight.toFixed(2)} (${(normEnvRight * 100).toFixed(2)}%)`,
      //   `â†’ dx: ${player.dx}`
      // );

    }


    function handleNotification(event) {
      const value = event.target.value;
      if (value.byteLength === NEW_PACKET_LEN) {
        for (let i = 0; i < NEW_PACKET_LEN; i += SINGLE_SAMPLE_LEN) {
          const sampleBuf = value.buffer.slice(i, i + SINGLE_SAMPLE_LEN);
          processSample(new DataView(sampleBuf));
        }
      } else if (value.byteLength === SINGLE_SAMPLE_LEN) {
        processSample(new DataView(value.buffer));
      }
    }

    window.onload = function () {
      const connectBtn = document.getElementById("connectBtn");
      const disconnectBtn = document.getElementById("disconnectBtn");
      const startBtn = document.getElementById("startBtn");
      const stopBtn = document.getElementById("stopBtn");
      const gainSlider = document.getElementById("gainSlider");
      const channelSelector = document.getElementById("channelSelector");

      let device = null, server = null, controlChar = null, dataChar = null;
      let streaming = false, connected = false;

      function updateButtonStates() {
        connectBtn.disabled = connected || streaming;
        disconnectBtn.disabled = !connected;
        startBtn.disabled = !connected || streaming;
        stopBtn.disabled = !streaming;
        channelSelector.disabled = !connected;
        gainSlider.disabled = !connected;

        const statusEl = document.getElementById("statusText");
        if (!connected) statusEl.textContent = "Not connected";
        else if (!streaming) statusEl.textContent = "Connected but not streaming";
        else statusEl.textContent = "Connected and streaming data";
      }

      async function connectBLE() {
        try {
          if (!navigator.bluetooth) {
            alert("Web Bluetooth API not available.");
            return;
          }
          device = await navigator.bluetooth.requestDevice({
            filters: [{ namePrefix: "NPG" }],
            optionalServices: ["4fafc201-1fb5-459e-8fcc-c5c9c331914b"],
          });
          server = await device.gatt.connect();
          const service = await server.getPrimaryService("4fafc201-1fb5-459e-8fcc-c5c9c331914b");
          controlChar = await service.getCharacteristic("0000ff01-0000-1000-8000-00805f9b34fb");
          dataChar = await service.getCharacteristic("beb5483e-36e1-4688-b7f5-ea07361b26a8");

          connected = true;
          streaming = false;
          updateButtonStates();
          console.log("Device connected.");
        } catch (err) {
          console.error("Connection error:", err);
          alert("Failed to connect: " + err.message);
        }
      }

      async function disconnectBLE() {
        try {
          if (device && device.gatt.connected) {
            if (streaming) await stopStream();
            device.gatt.disconnect();
          }
          connected = false;
          streaming = false;
          updateButtonStates();
        } catch (err) {
          console.error("Disconnect error:", err);
        }
      }

      async function startStream() {
        try {
          await controlChar.writeValue(new TextEncoder().encode("START"));
          await dataChar.startNotifications();
          dataChar.addEventListener("characteristicvaluechanged", handleNotification);
          streaming = true;
          updateButtonStates();
        } catch (err) {
          alert("Failed to start streaming: " + err.message);
        }
      }

      async function stopStream() {
        try {
          await dataChar.stopNotifications();
          dataChar.removeEventListener("characteristicvaluechanged", handleNotification);
          streaming = false;
          updateButtonStates();
        } catch (err) {
          console.error("Stop error:", err);
        }
      }

      // Assign event listeners after DOM is ready
      connectBtn.addEventListener("click", connectBLE);
      disconnectBtn.addEventListener("click", disconnectBLE);
      startBtn.addEventListener("click", startStream);
      stopBtn.addEventListener("click", stopStream);
    };

  </script>

</body>

</html>